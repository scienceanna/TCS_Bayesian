---
title: "Supplementary Materials: Pilot Analysis"
author: "ADF Clarke and AE Hughes"
output: bookdown::html_document2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
   fig.height = 3,
  fig.align = "center")

```

# Intro

## Setup and Data Import

```{r load-packages, include = FALSE}
library(tidyverse)
library(brms)
library(tidybayes)
library(patchwork)
library(latex2exp)
library(ggpmisc)
```

```{r}
# set ggplot2 theme
theme_set(see::theme_abyss())

# use parallel cores for mcmc chains!
options(mc.cores = parallel::detectCores())

# reduce the number of decimal places
options(digits = 3)

# functions used for our Bayesian re-analysis
source("../scripts/our_functions.R")

# set seed to make sure everything is reproducible 
set.seed(100320021)
```

## Import and Remove Outliers 

We will import data from pilot experiment. 

```{r import-data}
source("1_pre_process_pilot.R")

summary(d1)
summary(d2)
```

# Fit Models to Data

```{r}

# source("2_fit_pilot_models.R")

```

todo : plot prior predictions

## Hypothesis 1 

Verify that using a shift-lognormal gives a better mdoel than a lognormal or normal.

```{r, cache=TRUE}
m_sft <- readRDS("pilot1.model")
m_nrl <- readRDS("pilot1_normal.model")
m_log <- readRDS("pilot1_lognormal.model")

tibble(model = c("shifted lognormal", "normal", "lognormal"),
  LOO = model_weights(m_sft, m_nrl, m_log, weights = "loo"),
             WAIC = model_weights(m_sft, m_nrl, m_log, weights = "waic")) %>%
  knitr::kable()
```

Some plots to illustrate model:

```{r}
d1 %>% group_by(feature, lnd, observer) %>%
  summarise(median_rt = median(rt)) %>%
  summarise(mean_median = mean(median_rt)) -> d_mean
  
d1 %>% modelr::data_grid(feature, lnd) %>%
  add_predicted_draws(m_sft, re_formula = NA) %>%
  mean_hdci(.width = c(0.53, 0.97)) %>%
  ggplot(aes(lnd)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper, group = .width), alpha = 0.3, fill = "pink") + 
  geom_point(data = d_mean, aes(y = mean_median), alpha = 1, colour = "white") + 
  facet_wrap(~feature, nrow = 1)

d1 %>% modelr::data_grid(feature, lnd) %>%
  add_predicted_draws(m_log, re_formula = NA) %>%
  mean_hdci(.width = c(0.53, 0.97)) %>%
  ggplot(aes(lnd)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper, group = .width), alpha = 0.3, fill = "pink") + 
  geom_point(data = d_mean, aes(y = mean_median), alpha = 1, colour = "white") + 
  facet_wrap(~feature, nrow = 1)

d1 %>% modelr::data_grid(feature, lnd) %>%
  add_predicted_draws(m_nrl, re_formula = NA) %>%
  mean_hdci(.width = c(0.53, 0.97)) %>%
  ggplot(aes(lnd)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper, group = .width), alpha = 0.3, fill = "pink") + 
  geom_point(data = d_mean, aes(y = mean_median), alpha = 1, colour = "white") + 
  facet_wrap(~feature, nrow = 1)

rm(m_nrl, m_log)
```

## Hypothesis 2

Verify that using log(number of distracters) is superior to n(distracters).

```{r, cache=TRUE}
m_lin <- readRDS("pilot1_linear.model")

tibble(model = c("loglinear in n", "linear in n"),
             LOO = model_weights(m_sft, m_lin, weights = "loo"),
             WAIC = model_weights(m_sft, m_lin, weights = "waic")) %>%
  knitr::kable()

rm(m_lin, m_sft)
```

# Hypothesis 3

## Fixed effect of D (group average)

Can we predict $D$ in the double-feature case from data in the single-feature case?

```{r}
source("get_slopes_fun.R")

m1 <- readRDS("pilot1.model")
samples1 <- get_slopes(m1, 1) %>% select(-observer, -rD) %>% distinct()


samples1 %>% mutate(feature_type = if_else(
  feature %in% c("purple", "orange", "pink"), "colour", "shape")) %>%
  ggplot(aes(D, fill = feature)) + 
  geom_density(alpha = 0.33) + 
  facet_wrap(~feature_type)


m2 <- readRDS("pilot2_random.model") 
samples2 <- get_slopes(m2, 1) %>% select(-observer, -rD) %>% distinct()

samples2 %>% separate(feature, into = c("colour", "shape")) %>%
  ggplot(aes(D, fill = colour)) + 
  geom_density(alpha = 0.33) + 
  facet_grid(.~shape)

```

```{r}

calc_D <- function(feature1, feature2) {
  
  D1 <- filter(samples1, feature == feature1)$D
  D2 <- filter(samples1, feature == feature2)$D
  
  # now calculate D_overall using the three proposed methods
  D_collinear = 1/((1/D1) + (1/D2))
  D_best_feature = pmin(D1, D2)
  D_orth_contrast =  1/sqrt(1/(D1^2) + (1/D2^2))
  
 return(tibble(.draw = 1:2000,
               feature = paste(feature1, feature2, sep = "_"),
                feature1 = feature1, feature2 = feature2,
                collinear = D_collinear,
                `best feature` = D_best_feature,
                `orthogonal contrast` = D_orth_contrast))
  
}


things_to_calc <- samples2 %>% select( -D, -.draw) %>%
  distinct() %>%
  separate(feature, c("feature1", "feature2"))


slopes <- pmap_df(things_to_calc, calc_D) %>% full_join(samples2, by = c(".draw", "feature")) %>%
  pivot_longer(c(collinear, `best feature`, `orthogonal contrast`), names_to = "method", values_to = "Dp") %>%
  select(-feature, -.draw) %>%
  pivot_longer(c(D, Dp), names_to = "type", values_to = "D") %>%
  group_by(feature1, feature2, method, type)

slopes %>%
  median_hdci(D) %>%
  unite(D, D, .lower, .upper) %>%
  select(-.width, -.point, -.interval) %>%
  pivot_wider(names_from = "type", values_from = "D") %>%
  separate(D, into = c("De", "De_min", "De_max"), sep = "_", convert = TRUE) %>%
  separate(Dp, into = c("Dp", "Dp_min", "Dp_max"), sep = "_", convert=  TRUE) %>%
  ggplot(aes(x = Dp, xmin = Dp_min, xmax = Dp_max, y = De, ymin = De_min, ymax = De_max)) + 
  geom_point() + geom_errorbar(alpha = 0.5, colour = "yellow") + geom_errorbarh(alpha = 0.5, colour = "yellow") + 
  geom_abline(linetype = 2) + 
  geom_smooth(method = "lm", fullrange  = T, colour = "violetred3") + 
      stat_poly_eq(formula = y ~ x, 
               aes(label = paste(..eq.label.., ..rr.label.., sep = "*plain(\",\")~")), 
               parse = TRUE, size = 2.8, label.y = 0.9, coef.digits = 3, rr.digits = 4, colour="yellow1") +
  facet_wrap(~method, scales = "free") +
  scale_colour_manual(values = c("yellow1", "yellow1", "yellow1"))

slopes  %>%
  summarise(mu = mean(D),
            sd = sd(D)) %>%
  mutate(method = str_remove(method, "D_"),
         slope = paste0("feature", feature1, "_", feature2, ":lnd"))



```