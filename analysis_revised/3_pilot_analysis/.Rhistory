library(tidyverse)
library(ggthemes)
library(brms)
library(tidybayes)
#library(corrr)
library(patchwork)
options(digits = 2, mc.cores = 10)
knitr::opts_chunk$set(echo = TRUE)
theme_set(theme_bw())
source("plot_ddm_model.R")
d <- read_csv("../data_collected_by_level_3/Rt_accuracy_extracted.txt") %>%
select(-age, -sex, -n) %>%
select(obs = "observer", type = "targetType", targ = "targetPres", nD = "numDist", rt, accuracy) %>%
mutate(targ = as_factor(targ),
targ = fct_recode(targ, absent = "0", present = "1"),
type = as_factor(type))
d %>% group_by(obs,  targ) %>%
summarise(accuracy = mean(accuracy)) %>%
filter(accuracy < 0.75) -> to_remove
to_remove %>% knitr::kable()
d <- filter(d, !(obs %in% unique(to_remove$obs)))
d <- filter(d, nD == 15)
summary(d)
d %>% group_by(obs, type, targ) %>%
summarise(accuracy = mean(accuracy)) %>%
pivot_wider(names_from = "type", values_from = "accuracy") -> d_acc
ggplot(d_acc, aes(x = redHorizontal, y = greenVertical)) +
geom_abline(linetype = 2) +
geom_jitter(alpha = 0.5) +
facet_wrap(~targ)
with(filter(d_acc, targ == "absent"),  cor.test(greenVertical, redHorizontal))
with(filter(d_acc, targ == "present"),  cor.test(greenVertical, redHorizontal))
min_rt = quantile(d$rt, 0.005)
max_rt = quantile(d$rt, 0.995)
ggplot(d, aes(x = rt)) + geom_histogram(bins = 100) +
geom_vline(xintercept = c(min_rt, max_rt), linetype = 2) +
scale_x_log10() +
coord_cartesian(xlim = c(0.1, 10)) +
ggtitle("all RTs")
d <- filter(d, rt>min_rt, rt<max_rt)
d %>% group_by(obs, type, targ) %>%
summarise(rt = median(rt)) %>%
pivot_wider(names_from = "type", values_from = "rt") -> d_rt
ggplot(d_rt, aes(x = redHorizontal, y = greenVertical)) +
geom_abline(linetype = 2) +
geom_jitter(alpha = 0.5) +
facet_wrap(~targ)
with(filter(d_rt, targ == "absent"),  cor.test(greenVertical, redHorizontal))
with(filter(d_rt, targ == "present"),  cor.test(greenVertical, redHorizontal))
d$response <- NA
d$response[which(d$targ=="present" & d$accuracy==1)] = 1
d$response[which(d$targ=="present" & d$accuracy==0)] = 0
d$response[which(d$targ=="absent" & d$accuracy==1)] = 0
d$response[which(d$targ=="absent" & d$accuracy==0)] = 1
write_csv(d, "../cluster_level3/data_for_model.csv")
m <- readRDS("models/level3_full.model")
pred_wiener <- read_csv("predictions_full.csv")
pred_wiener <- read_csv("predictions_full.csv")
ggplot(pred_wiener, aes(x = rt, fill = emp_pre)) +
geom_density(alpha = 0.25) +
facet_grid(nD~targ) +
coord_cartesian(xlim = c(0, 2))
pred_wiener
ggplot(pred_wiener, aes(x = rt, fill = emp_pre)) +
geom_density(alpha = 0.5) +
facet_grid(nD~targ) +
coord_cartesian(xlim = c(0, 2))
ggplot(pred_wiener, aes(x = rt, fill = as.factor(emp_pre))) +
geom_density(alpha = 0.5) +
facet_grid(nD~targ) +
coord_cartesian(xlim = c(0, 2))
ggplot(pred_wiener, aes(x = rt, colour = emp_pre)) +
geom_density(alpha = 0.5) +
facet_grid(nD~targ) +
coord_cartesian(xlim = c(0, 2))
d
pred_wiener <- d %>% add_predicted_draws(m,negative_rt = TRUE, n = 100) %>%
ungroup() %>%
select(-.chain, -.draw, -.iteration, -.row) %>%
mutate(rt = if_else(response == 1, rt, -rt)) %>%
pivot_longer(c(rt, .prediction), names_to = "emp_pre", values_to = "rt") %>%
select(-response, -accuracy) %>%
mutate(emp_pre = fct_recode(emp_pre, empirical = "rt", prediction = ".prediction"),
response = if_else(rt < 0, "absent", "present"),
response = as_factor(response),
accuracy = response == targ,
rt = abs(rt))
setwd("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis")
library(tidyverse)
library(brms)
source("1_pre_process_pilot.R")
# use parallel cores for mcmc chains!
options(mc.cores = parallel::detectCores())
n_chains = 4
n_itr = 1000
d2 <- d2 %>% unite(feature, feature1, feature2)
my_f <- bf(rt ~ feature:lnd + (feature:lnd|observer),
ndt ~ 1 + (1|observer))
my_inits <- list(list(Intercept_ndt = -10), list(Intercept_ndt = -10), list(Intercept_ndt = -10), list(Intercept_ndt = -10))
my_prior <- c(
prior_string("normal(-0.5, 0.3)", class = "Intercept"),
prior_string("normal(0, 0.2)", class = "b"),
prior_string("normal(-1, 0.5)", class = "Intercept", dpar = "ndt" ),
prior_string("cauchy(0, 0.4)", class = "sigma"),
prior_string("cauchy(0, 0.05)", class = "sd"),
prior_string("cauchy(0, 0.05)", class = "sd", dpar = "ndt"))
# now run model
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
inits = my_inits,
##stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
saveRDS(m, "pilot2_random.model")
summary(d2)
# now run model
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
inits = my_inits,
##stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
saveRDS(m, "pilot2_random.model")
m
my_f <- bf(rt ~ observer:feature:lnd,
ndt ~ 0 + observer)
my_inits <- list(list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))))
my_prior <- c(
prior_string("normal(-0.5, 0.3)", class = "Intercept"),
prior_string("normal(0, 0.2)", class = "b"),
prior_string("normal(-1, 0.5)", class = "b", dpar = "ndt" ),
prior_string("cauchy(0, 0.4)", class = "sigma"))
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
inits = my_inits,
#stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
saveRDS(m, "pilot2_fixed.model")
my_f <- bf(rt ~ observer:feature:lnd,
ndt ~ 0 + observer)
my_inits <- list(list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))))
my_prior <- c(
prior_string("normal(-0.5, 0.3)", class = "Intercept"),
prior_string("normal(0, 0.2)", class = "b"),
prior_string("normal(-1, 0.5)", class = "b", dpar = "ndt" ),
prior_string("cauchy(0, 0.4)", class = "sigma"))
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
inits = my_inits,
#stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
saveRDS(m, "pilot2_fixed.model")
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = 1,
iter = n_itr,
inits = my_inits,
#stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
my_inits <- list(list(b_ndt = as.array(rep(-10, 6))),list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))),list(b_ndt = as.array(rep(-10, 4))))
my_prior <- c(
prior_string("normal(-0.5, 0.3)", class = "Intercept"),
prior_string("normal(0, 0.2)", class = "b"),
prior_string("normal(-1, 0.5)", class = "b", dpar = "ndt" ),
prior_string("cauchy(0, 0.4)", class = "sigma"))
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
inits = my_inits,
#stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
my_inits <- list(list(b_ndt = as.array(rep(-10, 6))),list(b_ndt = as.array(rep(-10, 6))),list(b_ndt = as.array(rep(-10, 6))),list(b_ndt = as.array(rep(-10, 6))))
my_prior <- c(
prior_string("normal(-0.5, 0.3)", class = "Intercept"),
prior_string("normal(0, 0.2)", class = "b"),
prior_string("normal(-1, 0.5)", class = "b", dpar = "ndt" ),
prior_string("cauchy(0, 0.4)", class = "sigma"))
m <- brm(
my_f,
data = d2,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
inits = my_inits,
#stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
saveRDS(m, "pilot2_fixed.model")
m
source("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis/sim_sens.R", echo=TRUE)
install.packages("matrix")
install.packages("Matrix")
install.packages("Matrix")
library(tidyverse)
source("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis/sim_sens.R", echo=TRUE)
# now run model
m <- brm(
my_f,
data = d,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
init = my_inits,
##stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
update.packages()
source("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis/sim_sens.R", echo=TRUE)
install.packages("Matrix")
install.packages("Matrix")
source("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis/sim_sens.R", echo=TRUE)
library(tidyverse)
install.packages("Matrix")
install.packages("Matrix")
library(tidyverse)
library(tidybayes)
library(brms)
# use parallel cores for mcmc chains!
options(mc.cores = parallel::detectCores())
n_chains = 4
n_itr = 1000
source("1_pre_process_pilot.R")
d2 %>% unite(feature, feature1, feature2) %>%
bind_rows(d1) -> d
my_f <- bf(rt ~ feature:lnd + (feature:lnd|observer),
ndt ~ 1 + (1|observer))
my_inits <- list(list(Intercept_ndt = -10), list(Intercept_ndt = -10), list(Intercept_ndt = -10), list(Intercept_ndt = -10))
my_prior <- c(
prior_string("normal(-0.5, 0.3)", class = "Intercept"),
prior_string("normal(0, 0.2)", class = "b"),
prior_string("normal(-1, 0.5)", class = "Intercept", dpar = "ndt" ),
prior_string("cauchy(0, 0.4)", class = "sigma"),
prior_string("cauchy(0, 0.05)", class = "sd"),
prior_string("cauchy(0, 0.05)", class = "sd", dpar = "ndt"))
# now run model
m <- brm(
my_f,
data = d,
family = brmsfamily("shifted_lognormal"),
prior = my_prior,
chains = n_chains,
iter = n_itr,
init = my_inits,
##stanvars = my_stanvar,
save_pars = save_pars(all=TRUE),
silent = TRUE
)
install.packages("rstan")
install.packages("rstan")
source("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis/sim_sens.R", echo=TRUE)
remove.packages(c("StanHeaders", "rstan"))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
source("~/GitHub/TCS_Bayesian/analysis_revised/3_pilot_analysis/sim_sens.R", echo=TRUE)
saveRDS(m, "sim_sense.model")
readRDS("sim_sens.R")
readRDS("sim_sens.model")
readRDS("sim_sense.model")
m
m <- readRDS("sim_sense.model")
m
d %>% modelr::data_grid(feature, lnd)
n_obs = 50
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
?add_predicted_draws
?add_predicted_draws
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(allow_new_levels = TRUE )
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(m, allow_new_levels = TRUE )
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(m, allow_new_levels = TRUE, ndraws = n_trials )
n_trials <- 100
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(m, allow_new_levels = TRUE, ndraws = n_trials )
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(m, allow_new_levels = TRUE, ndraws = n_trials) %>%
select(observer, feature, lnd, rt = ".prediction") -> dsim
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(m, allow_new_levels = TRUE, ndraws = n_trials) %>%
ungroup %>%
select(observer, feature, lnd, rt = ".prediction") -> dsim
dsim
summary(d)
library(tidyverse)
library(tidybayes)
library(brms)
m <- readRDS("sim_sense.model")
n_obs <-  50
n_trials <- 15
d %>% modelr::data_grid(feature, lnd, observer = 1:n_obs) %>%
add_predicted_draws(m, allow_new_levels = TRUE, ndraws = n_trials) %>%
ungroup %>%
select(observer, feature, lnd, rt = ".prediction") -> dsim
d
dsim
unique(dsim$feature)
d1 <- filter(dsim, !str_detect(feature, "_"))
d1
unique(d1$feature)
d2 <- filter(dsim, str_detect(feature, "_"))
unique(d2$feature)
d2 <- filter(dsim, str_detect(feature, "_")) %>% split(feature, feature1, feature2)
d2 <- filter(dsim, str_detect(feature, "_")) %>% separate(feature, feature1, feature2)
d2 <- filter(dsim, str_detect(feature, "_")) %>% separate(feature, c("feature1", "feature2"))
d2
