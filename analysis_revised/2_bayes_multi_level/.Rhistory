plt_sft <- plot_model_fits_rt(training_models, m_exp1_sft, plot_type = "predicted", y_limits = c(0, 2.5))
# plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "predicted", y_limits = c(0, 2.5))
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
m_exp3_nrl <- readRDS("models/exp_3_nrl.models")
m_exp3_log <- readRDS("models/exp_3_log.models")
m_exp3_sft <- readRDS("models/exp_3_sft.models")
#m_exp1_sft_nolog <- readRDS("models/exp_1_3_sft_nolog.models")
training_models = c("3a", "3b")
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "fitted")
m_exp3_nrl
training_models <- c("3a", "3b")
mdl_inputs_nrl <- set_up_model(training_models, "normal")
m_exp3_nrl <- run_model(mdl_inputs_nrl, ppc = "no")
saveRDS(m_exp3_nrl, "models/exp_3_nrl.models")
mdl_inputs_log <- set_up_model(training_models, "lognormal")
m_exp3_log <- run_model(mdl_inputs_log, ppc = "no")
saveRDS(m_exp3_log, "models/exp_3_log.models")
mdl_inputs_sft <- set_up_model(training_models, "shifted_lognormal")
m_exp3_sft <- run_model(mdl_inputs_sft, ppc = "no")
saveRDS(m_exp3_sft, "models/exp_3_sft.models")
training_models = c("3a", "3b")
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "fitted")
plt_sft <- plot_model_fits_rt(training_models, m_exp3_sft, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "fitted")
plt_sft <- plot_model_fits_rt(training_models, m_exp3_sft, plot_type = "fitted")
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "predicted", y_limits = c(0, 2.5))
exps_to_model <- c("2a", "2b", "2c")
mdl_inputs_sft <- set_up_model(exps_to_model , "shifted_lognormal")
m_exp_sft <- run_model(mdl_inputs_sft, ppc = "no")
saveRDS(m_exp_sft, "models/exp_2_sft.models")
slopes1 <- extract_fixed_slopes_from_model(m_exp1_sft)
slopes2 <- extract_fixed_slopes_from_model(m_exp2_sft)
slopes3 <- extract_fixed_slopes_from_model(m_exp3_sft)
bind_rows(
slopes1 %>% mutate(exp = "Experiment 1"),
slopes3 %>% mutate(exp = "Experiment 3")) %>%
ggplot(aes(x= D, fill = d_feature)) +
geom_density(alpha = 0.5) +
facet_wrap(~exp, nrow = 2)
#### Set up and data import ####
library(tidyverse)
library(brms)
library(tidybayes)
library(patchwork)
library(magrittr)
# use parallel cores for mcmc chains!
options(mc.cores = 6)
# functions used for the analysis implementation
source("../scripts/reimplementation.R")
# functions used for our Bayesian re-analysis
source("../scripts/our_functions.R")
# import and tidy data
source("../scripts/import_and_tidy.R")
# switch from ms to seconds
# Recode experiment as 1, 2, 3 and 4
d <- our_changes_to_data(d)
exps_to_model <- c("4a", "4b", "4c")
mdl_inputs_sft <- set_up_model(exps_to_model , "shifted_lognormal")
m_exp_sft <- run_model(mdl_inputs_sft, ppc = "no")
saveRDS(m_exp_sft, "models/exp_4_sft.models")
summary(m_exp_sft)
knitr::opts_chunk$set(
echo = TRUE,
fig.height = 3,
fig.align = "center")
library(tidyverse)
library(brms)
library(tidybayes)
library(patchwork)
library(latex2exp)
# set ggplot2 theme
theme_set(see::theme_abyss())
# use parallel cores for mcmc chains!
options(mc.cores = parallel::detectCores())
# reduce the number of decimal places
options(digits = 3)
# functions used for our Bayesian re-analysis
source("../scripts/our_functions.R")
# set seed to make sure everything is reproducible
set.seed(100320021)
source("../scripts/import_and_tidy.R")
summary(d)
# switch from ms to seconds
# recode experiment as 1, 2, 3 and 4
# remove outlier RTs
d <- our_changes_to_data(d)
prior_model_nrl <- readRDS("models/prior_nrl.models")
prior_model_log <- readRDS("models/prior_log.models")
prior_model_sft <- readRDS("models/prior_sft.models")
plt_nrl <- plot_model_fits_rt(1, prior_model_nrl, y_limits = c(-2, 10),feature2plot = "blue")
plt_log <- plot_model_fits_rt(1, prior_model_log, y_limits = c(0, 10), feature2plot = "blue")
plt_sft <- plot_model_fits_rt(1, prior_model_sft, y_limits = c(0, 10), feature2plot = "blue")
#plt_nrl + plt_log + plt_sft
# tidy up, we no longer need to keep hold of these models and plots
rm(
prior_model_nrl,
prior_model_log,
prior_model_sft,
plt_nrl, plt_log, plt_sft)
m_exp1_nrl <- readRDS("models/exp_1_nrl.models")
m_exp1_log <- readRDS("models/exp_1_log.models")
m_exp1_sft <- readRDS("models/exp_1_sft.models")
#m_exp1_sft_nolog <- readRDS("models/exp_1_3_sft_nolog.models")
training_models = c("1a", "1b")
plt_nrl <- plot_model_fits_rt(training_models, m_exp1_nrl, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp1_log, plot_type = "fitted")
plt_sft <- plot_model_fits_rt(training_models, m_exp1_sft, plot_type = "fitted")
#plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "fitted")
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
plt_nrl <- plot_model_fits_rt(training_models, m_exp1_nrl, plot_type = "predicted", y_limits = c(0, 2.5))
plt_log <- plot_model_fits_rt(training_models, m_exp1_log, plot_type = "predicted", y_limits = c(0, 2.5))
plt_sft <- plot_model_fits_rt(training_models, m_exp1_sft, plot_type = "predicted", y_limits = c(0, 2.5))
# plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "predicted", y_limits = c(0, 2.5))
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
bs_exp1_nrl <- bridge_sampler(m_exp1_nrl, silent = TRUE)
bs_exp1_log <- bridge_sampler(m_exp1_log, silent = TRUE)
bs_exp1_sft <- bridge_sampler(m_exp1_sft, silent = TRUE)
#bs_exp1_sft_nolog <- bridge_sampler(m_exp1_sft_nolog, silent = TRUE)
tibble(model = c("normal", "lognormal", "shifted-lognormal"), #, "linear in $N_T$"
weight = post_prob(bs_exp1_nrl, bs_exp1_log, bs_exp1_sft)) %>% # , bs_exp1_sft_nolog
knitr::kable()
#remove the models that we no longer need
rm(m_exp1_nrl, m_exp1_log, m_exp1_sft_nolog)
summary(m_exp1_sft)
plot(m_exp1_sft, pars = "^b_")
m_exp3_nrl <- readRDS("models/exp_3_nrl.models")
m_exp3_log <- readRDS("models/exp_3_log.models")
m_exp3_sft <- readRDS("models/exp_3_sft.models")
#m_exp1_sft_nolog <- readRDS("models/exp_1_3_sft_nolog.models")
training_models = c("3a", "3b")
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "fitted")
plt_sft <- plot_model_fits_rt(training_models, m_exp3_sft, plot_type = "fitted")
#plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "fitted")
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "predicted", y_limits = c(0, 2.5))
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "predicted", y_limits = c(0, 2.5))
plt_sft <- plot_model_fits_rt(training_models, m_exp3_sft, plot_type = "predicted", y_limits = c(0, 2.5))
#plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "predicted", y_limits = c(0, 2.5))
plt_nrl / plt_log / plt_sft# / plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
bs_exp1_nrl <- bridge_sampler(m_exp3_nrl, silent = TRUE)
bs_exp1_log <- bridge_sampler(m_exp3_log, silent = TRUE)
bs_exp1_sft <- bridge_sampler(m_exp3_sft, silent = TRUE)
#bs_exp1_sft_nolog <- bridge_sampler(m_exp1_sft_nolog, silent = TRUE)
tibble(model = c("normal", "lognormal", "shifted-lognormal"), #, "linear in $N_T$"
weight = post_prob(bs_exp1_nrl, bs_exp1_log, bs_exp1_sft)) %>% # , bs_exp1_sft_nolog
knitr::kable()
#remove the models that we no longer need
rm(m_exp1_nrl, m_exp1_log, m_exp1_sft_nolog)
#load previously fitted models
m_exp2_sft <- readRDS("models/exp_2_sft.models")
m_exp4_sft <- readRDS("models/exp_4_sft.models")
slopes1 <- extract_fixed_slopes_from_model(m_exp1_sft)
slopes2 <- extract_fixed_slopes_from_model(m_exp2_sft)
slopes3 <- extract_fixed_slopes_from_model(m_exp3_sft)
slopes4 <- extract_fixed_slopes_from_model(m_exp4_sft)
bind_rows(
slopes1 %>% mutate(exp = "Experiment 1"),
slopes3 %>% mutate(exp = "Experiment 3")) %>%
ggplot(aes(x= D, fill = d_feature)) +
geom_density(alpha = 0.5) +
facet_wrap(~exp, nrow = 2)
Dp_samples <- bind_rows(
get_Dp_samples(2, d, slopes1, slopes2),
get_Dp_samples(4, d, slopes3, slopes4))
Dp_samples <- bind_rows(
get_Dp_samples(2, d, slopes1, slopes2),
get_Dp_samples(4, d, slopes3, slopes4))
get_Dp_samples(2, d, slopes1, slopes2)
slopes1
knitr::opts_chunk$set(
echo = TRUE,
fig.height = 3,
fig.align = "center")
Dp_samples <- bind_rows(
get_Dp_samples(2, d, slopes1, slopes2),
get_Dp_samples(4, d, slopes3, slopes4))
get_Dp_samples(2a, d, slopes1, slopes2)
get_Dp_samples("2a", d, slopes1, slopes2)
map_dfr(c("2a", "2b"), get_Dp_samples, d, slopes1, slopes2)
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2)
Dp_samples <- bind_rows(
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2),
map_dfr(c("4a", "4b", "4c"), get_Dp_samples, d, slopes1, slopes2))
# get best possible linear fit of the various methods!
Dp_samples %>%
pivot_wider(
c(exp_id, d_feature, iter, De),
names_from = method, values_from = Dp) -> d_lmer
# find mle best fit
m_lmer <- lme4::lmer(data = d_lmer, De ~ best_feature + orthog_contrast + collinear + (1|iter))
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2)
m_lmer
d_lmer %>%
mutate(linear_comb = predict(m_lmer)) %>%
pivot_longer(
c(best_feature, orthog_contrast, collinear, linear_comb),
names_to = "method",
values_to = "Dp") %>%
mutate(method = fct_relevel(method, "linear_comb", after = Inf)) -> Dp_samples
Dp_lines <- get_Dp_lines(Dp_samples)
Dp_lines <- get_Dp_lines(Dp_samples)
plot_Dp_lines(Dp_lines)
Dp_lines
tail(Dp_lines)
Dp_samples
unique(Dp_samples$d_feature
)
Dp_samples <- bind_rows(
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2),
map_dfr(c("4a", "4b", "4c"), get_Dp_samples, d, slopes3, slopes4))
unique(Dp_samples$d_feature)
# find mle best fit
m_lmer <- lme4::lmer(data = d_lmer, De ~ best_feature + orthog_contrast + collinear + (1|iter))
d_lmer %>%
mutate(linear_comb = predict(m_lmer)) %>%
pivot_longer(
c(best_feature, orthog_contrast, collinear, linear_comb),
names_to = "method",
values_to = "Dp") %>%
mutate(method = fct_relevel(method, "linear_comb", after = Inf)) -> Dp_samples
rm(d_lmer, m_lmer)
Dp_lines <- get_Dp_lines(Dp_samples)
plot_Dp_lines(Dp_lines)
Dp_samples
unique(Dp_samples$exp_id)
unique(Dp_samples$d_feature)
plot_Dp_lines <- function(Dp_lines, dot_col = "yellow1", xyline_col = "cyan") {
# x_range = 0.25
# bind_rows(Dp_lines %>% mutate(x = 0, .lower = 0, .upper = 0),
# Dp_lines %>% mutate(x = x_range, .lower = x * .lower, .upper = x * .upper)) -> Dp_lines
Dp_samples %>%
group_by(exp_id, d_feature, method) %>%
mean_hdci(Dp, De) %>%
ggplot() +
geom_abline(linetype = 2, colour = xyline_col) +
geom_point(aes(x = Dp, y = De), color = dot_col) +
geom_linerange(aes(x = Dp, ymin = De.lower, ymax = De.upper), color = dot_col) +
# geom_linerange(aes(y = De, xmin = Dp.lower, xmax = Dp.upper), color = dot_col) +
geom_abline(data = Dp_lines, aes(intercept = intercept, slope = slope), colour = "palevioletred1", alpha = 0.1) +
facet_wrap(~method, nrow = 1) +
# geom_ribbon(data = Dp_lines, aes(x = x,  ymin = .lower, ymax=  .upper), alpha = 0.5, fill = "palevioletred1") +
#coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
scale_x_continuous(TeX("Predicted value for $D_{c,s}$"), expand = c(0, 0), breaks = c(0, 0.1, 0.2)) +
scale_y_continuous(TeX("empirical value for $D_{c,s}$"), expand = c(0, 0), breaks = c(0, 0.1, 0.2))
}
plot_Dp_lines(Dp_lines)
Dp_samples
Dp_samples %>% filter(exp_id = "4a")
Dp_samples %>% filter(exp_id == "4a")
Dp_samples <- bind_rows(
map_dfr(c("4a", "4b", "4c"), get_Dp_samples, d, slopes3, slopes4))
# get best possible linear fit of the various methods!
Dp_samples %>%
pivot_wider(
c(exp_id, d_feature, iter, De),
names_from = method, values_from = Dp) -> d_lmer
# find mle best fit
m_lmer <- lme4::lmer(data = d_lmer, De ~ best_feature + orthog_contrast + collinear + (1|iter))
d_lmer %>%
mutate(linear_comb = predict(m_lmer)) %>%
pivot_longer(
c(best_feature, orthog_contrast, collinear, linear_comb),
names_to = "method",
values_to = "Dp") %>%
mutate(method = fct_relevel(method, "linear_comb", after = Inf)) -> Dp_samples
rm(d_lmer, m_lmer)
Dp_lines <- get_Dp_lines(Dp_samples)
plot_Dp_lines(Dp_lines)
#### Set up and data import ####
library(tidyverse)
library(brms)
library(tidybayes)
library(patchwork)
library(magrittr)
# use parallel cores for mcmc chains!
options(mc.cores = 6)
# functions used for the analysis implementation
source("../scripts/reimplementation.R")
# functions used for our Bayesian re-analysis
source("../scripts/our_functions.R")
# import and tidy data
source("../scripts/import_and_tidy.R")
# switch from ms to seconds
# Recode experiment as 1, 2, 3 and 4
d <- our_changes_to_data(d)
d %>% group_by(exp_id) %>% summarise(minrt = min(rt))
#### Set up and data import ####
library(tidyverse)
library(brms)
library(tidybayes)
library(patchwork)
library(magrittr)
# use parallel cores for mcmc chains!
options(mc.cores = 6)
# functions used for the analysis implementation
source("../scripts/reimplementation.R")
# functions used for our Bayesian re-analysis
source("../scripts/our_functions.R")
# import and tidy data
source("../scripts/import_and_tidy.R")
# switch from ms to seconds
# Recode experiment as 1, 2, 3 and 4
d <- our_changes_to_data(d)
exps_to_model <- c("4a", "4b", "4c")
mdl_inputs_sft <- set_up_model(exps_to_model , "shifted_lognormal")
m_exp_sft <- run_model(mdl_inputs_sft, ppc = "no")
saveRDS(m_exp_sft, "models/exp_4_sft.models")
knitr::opts_chunk$set(
echo = TRUE,
fig.height = 3,
fig.align = "center")
library(tidyverse)
library(brms)
library(tidybayes)
library(patchwork)
library(latex2exp)
# set ggplot2 theme
theme_set(see::theme_abyss())
# use parallel cores for mcmc chains!
options(mc.cores = parallel::detectCores())
# reduce the number of decimal places
options(digits = 3)
# functions used for our Bayesian re-analysis
source("../scripts/our_functions.R")
# set seed to make sure everything is reproducible
set.seed(100320021)
source("../scripts/import_and_tidy.R")
summary(d)
# switch from ms to seconds
# recode experiment as 1, 2, 3 and 4
# remove outlier RTs
d <- our_changes_to_data(d)
prior_model_nrl <- readRDS("models/prior_nrl.models")
prior_model_log <- readRDS("models/prior_log.models")
prior_model_sft <- readRDS("models/prior_sft.models")
plt_nrl <- plot_model_fits_rt(1, prior_model_nrl, y_limits = c(-2, 10),feature2plot = "blue")
plt_log <- plot_model_fits_rt(1, prior_model_log, y_limits = c(0, 10), feature2plot = "blue")
plt_sft <- plot_model_fits_rt(1, prior_model_sft, y_limits = c(0, 10), feature2plot = "blue")
#plt_nrl + plt_log + plt_sft
# tidy up, we no longer need to keep hold of these models and plots
rm(
prior_model_nrl,
prior_model_log,
prior_model_sft,
plt_nrl, plt_log, plt_sft)
m_exp1_nrl <- readRDS("models/exp_1_nrl.models")
m_exp1_log <- readRDS("models/exp_1_log.models")
m_exp1_sft <- readRDS("models/exp_1_sft.models")
#m_exp1_sft_nolog <- readRDS("models/exp_1_3_sft_nolog.models")
training_models = c("1a", "1b")
plt_nrl <- plot_model_fits_rt(training_models, m_exp1_nrl, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp1_log, plot_type = "fitted")
plt_sft <- plot_model_fits_rt(training_models, m_exp1_sft, plot_type = "fitted")
#plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "fitted")
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
plt_nrl <- plot_model_fits_rt(training_models, m_exp1_nrl, plot_type = "predicted", y_limits = c(0, 2.5))
plt_log <- plot_model_fits_rt(training_models, m_exp1_log, plot_type = "predicted", y_limits = c(0, 2.5))
plt_sft <- plot_model_fits_rt(training_models, m_exp1_sft, plot_type = "predicted", y_limits = c(0, 2.5))
# plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "predicted", y_limits = c(0, 2.5))
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
bs_exp1_nrl <- bridge_sampler(m_exp1_nrl, silent = TRUE)
bs_exp1_log <- bridge_sampler(m_exp1_log, silent = TRUE)
bs_exp1_sft <- bridge_sampler(m_exp1_sft, silent = TRUE)
#bs_exp1_sft_nolog <- bridge_sampler(m_exp1_sft_nolog, silent = TRUE)
tibble(model = c("normal", "lognormal", "shifted-lognormal"), #, "linear in $N_T$"
weight = post_prob(bs_exp1_nrl, bs_exp1_log, bs_exp1_sft)) %>% # , bs_exp1_sft_nolog
knitr::kable()
#remove the models that we no longer need
rm(m_exp1_nrl, m_exp1_log, m_exp1_sft_nolog)
summary(m_exp1_sft)
plot(m_exp1_sft, pars = "^b_")
m_exp3_nrl <- readRDS("models/exp_3_nrl.models")
m_exp3_log <- readRDS("models/exp_3_log.models")
m_exp3_sft <- readRDS("models/exp_3_sft.models")
#m_exp1_sft_nolog <- readRDS("models/exp_1_3_sft_nolog.models")
training_models = c("3a", "3b")
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "fitted")
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "fitted")
plt_sft <- plot_model_fits_rt(training_models, m_exp3_sft, plot_type = "fitted")
#plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "fitted")
plt_nrl / plt_log / plt_sft #/ plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
plt_nrl <- plot_model_fits_rt(training_models, m_exp3_nrl, plot_type = "predicted", y_limits = c(0, 2.5))
plt_log <- plot_model_fits_rt(training_models, m_exp3_log, plot_type = "predicted", y_limits = c(0, 2.5))
plt_sft <- plot_model_fits_rt(training_models, m_exp3_sft, plot_type = "predicted", y_limits = c(0, 2.5))
#plt_sft_nolog <- plot_model_fits_rt(1, m_exp1_sft_nolog, plot_type = "predicted", y_limits = c(0, 2.5))
plt_nrl / plt_log / plt_sft# / plt_sft_nolog
rm(plt_nrl, plt_log, plt_sft, plt_sft_nolog)
bs_exp1_nrl <- bridge_sampler(m_exp3_nrl, silent = TRUE)
bs_exp1_log <- bridge_sampler(m_exp3_log, silent = TRUE)
bs_exp1_sft <- bridge_sampler(m_exp3_sft, silent = TRUE)
#bs_exp1_sft_nolog <- bridge_sampler(m_exp1_sft_nolog, silent = TRUE)
tibble(model = c("normal", "lognormal", "shifted-lognormal"), #, "linear in $N_T$"
weight = post_prob(bs_exp1_nrl, bs_exp1_log, bs_exp1_sft)) %>% # , bs_exp1_sft_nolog
knitr::kable()
#remove the models that we no longer need
rm(m_exp1_nrl, m_exp1_log, m_exp1_sft_nolog)
#load previously fitted models
m_exp2_sft <- readRDS("models/exp_2_sft.models")
m_exp4_sft <- readRDS("models/exp_4_sft.models")
slopes1 <- extract_fixed_slopes_from_model(m_exp1_sft)
slopes2 <- extract_fixed_slopes_from_model(m_exp2_sft)
slopes3 <- extract_fixed_slopes_from_model(m_exp3_sft)
slopes4 <- extract_fixed_slopes_from_model(m_exp4_sft)
bind_rows(
slopes1 %>% mutate(exp = "Experiment 1"),
slopes3 %>% mutate(exp = "Experiment 3")) %>%
ggplot(aes(x= D, fill = d_feature)) +
geom_density(alpha = 0.5) +
facet_wrap(~exp, nrow = 2)
Dp_samples <- bind_rows(
get_Dp_samples(2, d, slopes1, slopes2),
get_Dp_samples(4, d, slopes3, slopes4))
get_Dp_samples(2, d, slopes1, slopes2)
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2)
Dp_samples <- bind_rows(
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2),
map_dfr(c("4a", "4b", "4c"), get_Dp_samples, d, slopes1, slopes2))
# get best possible linear fit of the various methods!
Dp_samples %>%
pivot_wider(
c(exp_id, d_feature, iter, De),
names_from = method, values_from = Dp) -> d_lmer
# find mle best fit
m_lmer <- lme4::lmer(data = d_lmer, De ~ best_feature + orthog_contrast + collinear + (1|iter))
d_lmer %>%
mutate(linear_comb = predict(m_lmer)) %>%
pivot_longer(
c(best_feature, orthog_contrast, collinear, linear_comb),
names_to = "method",
values_to = "Dp") %>%
mutate(method = fct_relevel(method, "linear_comb", after = Inf)) -> Dp_samples
rm(d_lmer, m_lmer)
Dp_lines <- get_Dp_lines(Dp_samples)
Dp_lines <- get_Dp_lines(Dp_samples)
plot_Dp_lines(Dp_lines)
Dp_samples
Dp_samples %>% filter(exp_id == "4a")
Dp_samples <-    map_dfr(c("4a", "4b", "4c"), get_Dp_samples, d, slopes1, slopes2)
Dp_samples %>%
pivot_wider(
c(exp_id, d_feature, iter, De),
names_from = method, values_from = Dp) -> d_lmer
# find mle best fit
m_lmer <- lme4::lmer(data = d_lmer, De ~ best_feature + orthog_contrast + collinear + (1|iter))
d_lmer %>%
mutate(linear_comb = predict(m_lmer)) %>%
pivot_longer(
c(best_feature, orthog_contrast, collinear, linear_comb),
names_to = "method",
values_to = "Dp") %>%
mutate(method = fct_relevel(method, "linear_comb", after = Inf)) -> Dp_samples
rm(d_lmer, m_lmer)
Dp_lines <- get_Dp_lines(Dp_samples)
plot_Dp_lines(Dp_lines)
Dp_samples <- bind_rows(
map_dfr(c("2a", "2b", "2c"), get_Dp_samples, d, slopes1, slopes2),
map_dfr(c("4a", "4b", "4c"), get_Dp_samples, d, slopes1, slopes2))
# get best possible linear fit of the various methods!
Dp_samples %>%
pivot_wider(
c(exp_id, d_feature, iter, De),
names_from = method, values_from = Dp) -> d_lmer
# find mle best fit
m_lmer <- lme4::lmer(data = d_lmer, De ~ best_feature + orthog_contrast + collinear + (1|iter))
d_lmer %>%
mutate(linear_comb = predict(m_lmer)) %>%
pivot_longer(
c(best_feature, orthog_contrast, collinear, linear_comb),
names_to = "method",
values_to = "Dp") %>%
mutate(method = fct_relevel(method, "linear_comb", after = Inf)) -> Dp_samples
rm(d_lmer, m_lmer)
Dp_lines <- get_Dp_lines(Dp_samples)
plot_Dp_lines(Dp_lines)
plot_Dp_lines <- function(Dp_lines, dot_col = "yellow1", xyline_col = "cyan") {
# x_range = 0.25
# bind_rows(Dp_lines %>% mutate(x = 0, .lower = 0, .upper = 0),
# Dp_lines %>% mutate(x = x_range, .lower = x * .lower, .upper = x * .upper)) -> Dp_lines
Dp_samples %>%
group_by(exp_id, d_feature, method) %>%
mean_hdci(Dp, De) %>%
ggplot() +
geom_abline(linetype = 2, colour = xyline_col) +
geom_point(aes(x = Dp, y = De), color = dot_col) +
geom_linerange(aes(x = Dp, ymin = De.lower, ymax = De.upper), color = dot_col) +
# geom_linerange(aes(y = De, xmin = Dp.lower, xmax = Dp.upper), color = dot_col) +
geom_abline(data = Dp_lines, aes(intercept = intercept, slope = slope), colour = "palevioletred1", alpha = 0.1) +
facet_wrap(~method, nrow = 1) +
# geom_ribbon(data = Dp_lines, aes(x = x,  ymin = .lower, ymax=  .upper), alpha = 0.5, fill = "palevioletred1") +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
scale_x_continuous(TeX("Predicted value for $D_{c,s}$"), expand = c(0, 0), breaks = c(0, 0.1, 0.2)) +
scale_y_continuous(TeX("empirical value for $D_{c,s}$"), expand = c(0, 0), breaks = c(0, 0.1, 0.2))
}
plot_Dp_lines(Dp_lines)
Dp_samples
Dp_samples %>% group_by(exp_id, d_feature) %>% summarise(De = mean(De), Dp = mean(Dp))
Dp_lines
Dp_lines <- get_Dp_lines(Dp_samples %>% filter(exp_id %in% c("4a", "4b", "4c")))
plot_Dp_lines(Dp_lines)
Dp_lines <- get_Dp_lines(Dp_samples)
